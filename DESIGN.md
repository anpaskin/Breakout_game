game
====
The game's MainGame class extends the javafx Application class and, in its start method, declares and initializes a new GameDriver object. The GameDriver class is the main engine of the game and handles Scene changes and level navigation, as well as any shapes and objects that don't have their own classes including the paddle, the ball, and lazers. GameDriver sets levels by creating and placing Block objects, which contain a Rectangle, position coordinates, and several other status values. Block types are implemented within the Block class with an instance variable. GameDriver also uses a BlockManager object to keep track of all of the blocks in a level, all collisions that occur, and which blocks are destroyed. Finally, GameDriver uses the SplashScreen class to create the home, pause, and game over screens.

In order to add a new level, you must add an if statement to the chooseLevel method that calls a setLevelXXX method, which you must implement as well. Your new setLevelXXX method should call setBlockRow and pass in the parameters of your choice to place the blocks in the desired locations.

In order to add a new power-up, you must assign an integer 1-10 that is not already used to represent an existing power-up, and implement the new power-up and its integer in the deliverPowerUp and deactivatePowerUp methods of GameDriver. You also need to modify any other components of GameDriver and BlockManager that might be affected by the power-up, such as block and paddle collisions. This design allows you to implement power-ups directly in GameDriver and gives you the freedom to modify anything handled by GameDriver with your new power-up. This does, however, result in a more dispersed and potentially bug-prone implementation, as the power-ups are not implemented in their own classes.

In order to add a new block type, you must add a new block type conditional to the Block constructor. You will then have to modify and add to the components of Block and BlockManager that change with the addition of your new block type. This design allows you to implement new block types directly in Block. This does, however, result in a more dispersed and potentially bug-prone implementation, as the Blocks are not implemented in their own classes.